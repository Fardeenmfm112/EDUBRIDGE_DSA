ALGORITHMS :
1) Algorithm:

STEP 1  : Start

STEP 2  : Traverse the array.

STEP 3  : For each element, check if target - element exists in a hash map.

STEP 4  : If found, return the indices.

Else, store the element with its index in the hash map.

STEP 5  : Stop



2) Algorithm :

STEP 1  : Start

STEP 2 : Set low = 0, high = n - 1.

STEP 3 :While low <= high:

STEP 4 :Find mid = (low + high) / 2.

If arr[mid] == target, return mid.

If arr[mid] < target, search right half (low = mid + 1).

If arr[mid] > target, search left half (high = mid - 1).

If not found, return -1.

STEP 5  : Stop


3) Algorithm :

STEP 1 : Start

STEP 2 : Check if the lengths of the two strings are equal.

STEP 3 : Count the frequency of each character in both strings.

STEP 4 : Compare both frequency arrays â€” if equal, strings are anagrams.

STEP 5 : Stop


4) Algorithm :


STEP 1 : Start

STEP 2 : Use two pointers to represent a window and a hash array to track characters.

STEP 3 : Move the right pointer and include characters until a repeat is found.

STEP 4 : Move the left pointer to exclude the repeated character.

STEP 5 : Keep updating the maximum length during the process.

STEP 6 : Stop


5) Algorithm :

STEP 1 : Start

STEP 2 : A palindrome can center on one character (odd) or between two characters (even).

STEP 3  : For each index in the string:

Expand around the index as center (odd-length palindromes).

Expand between index and index+1 (even-length palindromes).

STEP 4 : Count all valid palindromes found this way.

STEP 5 : Stop

